name: Deploy microservices

on:
  workflow_call:
    inputs:
      action:
        description: 'update-microservices.sh action: apply|diff|sync'
        required: false
        default: 'apply'
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deploy
    runs-on: [github-k8s-dev-runner]
    container:
      image: dtzar/helm-kubectl:3.19
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: blockscout/actions/.github/actions/checkout@main
        with:
          fetch-depth: "1"

      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          helm plugin install https://github.com/jkroepke/helm-secrets
          helm plugin install https://github.com/databus23/helm-diff
          cd /tmp
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64|amd64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
            *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
          esac
          curl -sSLo helmfile.tgz https://github.com/helmfile/helmfile/releases/download/v1.1.0/helmfile_1.1.0_linux_${ARCH}.tar.gz
          tar -xzvf helmfile.tgz
          mv helmfile /usr/local/bin/helmfile
          chmod +x /usr/local/bin/helmfile
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${ARCH}
          chmod +x /usr/local/bin/yq

      - name: Get dev kubeconfigs from Rancher
        uses: blockscout/actions/.github/actions/rancher-kubeconfigs@main
        with:
          url: ${{ secrets.RANCHER_URL }}
          username: ${{ secrets.RANCHER_CI_DEV_USERNAME }}
          password: ${{ secrets.RANCHER_CI_DEV_PASSWORD }}
          clusterNames: "k8s-dev"

      - name: Get prod kubeconfigs from Rancher
        uses: blockscout/actions/.github/actions/rancher-kubeconfigs@main
        with:
          url: ${{ secrets.RANCHER_URL }}
          username: ${{ secrets.RANCHER_CI_PROD_USERNAME }}
          password: ${{ secrets.RANCHER_CI_PROD_PASSWORD }}
          clusterNames: "k8s-pg,k8s-prod-1,k8s-prod-2,k8s-prod-3,k8s-prod-4"

      - name: Get Vault token
        id: vault-token
        uses: blockscout/actions/.github/actions/vault@main
        with:
          url: https://vault.k8s.blockscout.com
          method: jwt
          role: ci-prod
          path: github-jwt
          jwtGithubAudience: "https://github.com/blockscout"
          tlsSkipVerify: "false"
          exportToken: "true"
          secrets: ""

      - name: Prepare kubeconfigs and contexts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.kube/config.d

          write_cfg() {
            local VAR_NAME="$1" FILE_NAME="$2" CTX_NAME="$3"
            local VAL=${!VAR_NAME:-}
            [[ -z "$VAL" ]] && return 0
            # Decode robustly even for multiline values
            printf %s "$VAL" | base64 -d > "$FILE_NAME"
            # Ensure file is non-empty
            if [[ ! -s "$FILE_NAME" ]]; then
              echo "Decoded kubeconfig is empty: $FILE_NAME" >&2
              return 1
            fi
            local CUR_CTX
            CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config current-context 2>/dev/null || true)
            if [[ -z "$CUR_CTX" ]]; then
              CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config get-contexts -o name | head -n1 || true)
            fi
            if [[ -n "$CUR_CTX" && "$CUR_CTX" != "$CTX_NAME" ]]; then
              kubectl --kubeconfig "$FILE_NAME" config rename-context "$CUR_CTX" "$CTX_NAME" || true
            fi
            echo "$FILE_NAME"
          }

          files=()
          
          # Dynamically find all KUBECONFIG_*_BASE64 environment variables
          for var in $(env | grep -E '^KUBECONFIG_.*_BASE64=' | cut -d= -f1); do
            # Extract cluster name from variable name
            # KUBECONFIG_K8S_DEV_BASE64 -> k8s-dev
            CLUSTER_NAME=$(echo "$var" | sed 's/^KUBECONFIG_//' | sed 's/_BASE64$//' | tr '[:upper:]' '[:lower:]' | tr '_' '-')
            
            FILE_PATH="${HOME}/.kube/config.d/${CLUSTER_NAME}"
            
            echo "Processing cluster: ${CLUSTER_NAME} from variable: ${var}"
            out=$(write_cfg "$var" "$FILE_PATH" "$CLUSTER_NAME" || true)
            [[ -n "${out}" ]] && files+=("$FILE_PATH")
          done

          if [[ ${#files[@]} -gt 0 ]]; then
            KUBECONFIG=$(IFS=: ; echo "${files[*]}")
            echo "KUBECONFIG=$KUBECONFIG" >> "$GITHUB_ENV"
            echo "Prepared ${#files[@]} kubeconfig(s)"
          else
            echo "Warning: No kubeconfig files were prepared" >&2
          fi

      - name: Run update-microservices.sh
        shell: bash
        run: |
          set -euo pipefail
          chmod +x helmfile/update-microservices.sh
          echo "KUBECONFIG=$KUBECONFIG"
          ls -l ${HOME}/.kube/config.d || true
          
          # Verify VAULT_TOKEN is available
          if [[ -z "${VAULT_TOKEN:-}" ]]; then
            echo "VAULT_TOKEN is not set!" >&2
            exit 1
          fi
          echo "VAULT_TOKEN is available"
          
          ACTION="${{ inputs.action }}"

          DEPLOY_FAILURES_FILE=$(mktemp)
          export DEPLOY_FAILURES_FILE

          # Dynamically determine available clusters by checking per-cluster kubeconfig files
          declare -a SELECTED=()
          for f in "${HOME}/.kube/config.d/"*; do
            if [[ -s "$f" ]]; then
              cluster_name=$(basename "$f")
              SELECTED+=("$cluster_name")
            fi
          done
          
          if [[ ${#SELECTED[@]} -eq 0 ]]; then
            echo "No per-cluster kubeconfig files found in ${HOME}/.kube/config.d" >&2
            exit 1
          fi
          
          echo "Found ${#SELECTED[@]} cluster(s): ${SELECTED[*]}"

          # Run sequentially per context, setting KUBECONFIG to the cluster-specific file
          # Continue on error to collect all failures, then fail at the end
          for ctx in "${SELECTED[@]}"; do
            echo "=== Running for context: ${ctx} ==="
            export KUBECONFIG="${HOME}/.kube/config.d/${ctx}"
            CMD=(./helmfile/update-microservices.sh "$ACTION" --clusters "$ctx")
            if [[ -z "${SERVICES_CSV:-}" ]]; then
              echo "Deploying all microservices in ${ctx}"
            else
              echo "Changed services in ${ctx}: ${SERVICES_CSV}"
              CMD+=("--services" "${SERVICES_CSV}")
            fi

            # Run and continue even on failure to collect all errors
            set +e
            "${CMD[@]}"
            EXIT_CODE=$?
            set -e
            
            if [[ $EXIT_CODE -ne 0 ]]; then
              echo "Deployment script failed for ${ctx} with exit code ${EXIT_CODE}" >&2
            fi
            
            # Debug info
            if [[ -f "$DEPLOY_FAILURES_FILE" ]]; then
               CURRENT_COUNT=$(wc -l < "$DEPLOY_FAILURES_FILE")
               echo "DEBUG: Current failures count: ${CURRENT_COUNT}"
            else
               echo "DEBUG: Failure file not found!"
            fi
          done

          # Check if any deployments failed and report all of them
          if [[ -s "$DEPLOY_FAILURES_FILE" ]]; then
            echo ""
            echo "========================================" 
            echo "FAILED DEPLOYMENTS SUMMARY"
            echo "========================================"
            cat "$DEPLOY_FAILURES_FILE"
            echo "========================================"
            FAILURE_COUNT=$(wc -l < "$DEPLOY_FAILURES_FILE" 2>/dev/null || echo 0)
            echo "Total failed deployments: ${FAILURE_COUNT}"
            echo ""
            exit 1
          fi
          
          echo ""
          echo "All deployments completed successfully"


