name: Deploy microservices

on:
  workflow_call:
    inputs:
      action:
        description: 'update-microservices.sh action: apply|diff|sync'
        required: false
        default: 'apply'
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deploy
    runs-on: [github-k8s-dev-runner]
    container:
      image: dtzar/helm-kubectl:3.19
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: blockscout/actions/.github/actions/checkout@main
        with:
          fetch-depth: "1"

      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          helm plugin install https://github.com/jkroepke/helm-secrets
          helm plugin install https://github.com/databus23/helm-diff
          cd /tmp
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64|amd64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
            *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
          esac
          curl -sSLo helmfile.tgz https://github.com/helmfile/helmfile/releases/download/v1.1.0/helmfile_1.1.0_linux_${ARCH}.tar.gz
          tar -xzvf helmfile.tgz
          mv helmfile /usr/local/bin/helmfile
          chmod +x /usr/local/bin/helmfile
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${ARCH}
          chmod +x /usr/local/bin/yq

      - name: Get kubeconfigs from Rancher
        shell: bash
        env:
          RANCHER_URL: ${{ secrets.RANCHER_URL }}
          RANCHER_USERNAME: ${{ secrets.RANCHER_CI_PROD_USERNAME }}
          RANCHER_PASSWORD: ${{ secrets.RANCHER_CI_PROD_PASSWORD }}
        run: |
          set -euo pipefail
          
          # Login to Rancher and get token
          echo "Authenticating to Rancher..."
          LOGIN_RESPONSE=$(curl -sk -X POST "${RANCHER_URL}/v3-public/localProviders/local?action=login" \
            -H 'Content-Type: application/json' \
            -d "{\"username\":\"${RANCHER_USERNAME}\",\"password\":\"${RANCHER_PASSWORD}\"}")
          
          TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.token')
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
            echo "Failed to authenticate to Rancher" >&2
            exit 1
          fi
          
          echo "Successfully authenticated to Rancher"
          
          # Get list of all clusters
          CLUSTERS_RESPONSE=$(curl -sk -X GET "${RANCHER_URL}/v3/clusters" \
            -H "Authorization: Bearer ${TOKEN}")
          
          # Extract cluster IDs and names
          CLUSTER_DATA=$(echo "$CLUSTERS_RESPONSE" | jq -r '.data[] | "\(.id):\(.name)"')
          
          # For each cluster, get kubeconfig
          while IFS=: read -r CLUSTER_ID CLUSTER_NAME; do
            echo "Fetching kubeconfig for cluster: ${CLUSTER_NAME} (${CLUSTER_ID})"
            
            KUBECONFIG_RESPONSE=$(curl -sk -X POST "${RANCHER_URL}/v3/clusters/${CLUSTER_ID}?action=generateKubeconfig" \
              -H "Authorization: Bearer ${TOKEN}")
            
            KUBECONFIG_CONTENT=$(echo "$KUBECONFIG_RESPONSE" | jq -r '.config')
            
            if [[ -z "$KUBECONFIG_CONTENT" || "$KUBECONFIG_CONTENT" == "null" ]]; then
              echo "Warning: Failed to get kubeconfig for cluster ${CLUSTER_NAME}" >&2
              continue
            fi
            
            # Base64 encode and export to environment
            KUBECONFIG_BASE64=$(echo "$KUBECONFIG_CONTENT" | base64 -w 0)
            
            # Normalize cluster name for environment variable
            ENV_VAR_NAME=$(echo "KUBECONFIG_${CLUSTER_NAME}_BASE64" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
            
            echo "${ENV_VAR_NAME}=${KUBECONFIG_BASE64}" >> "$GITHUB_ENV"
            echo "Exported kubeconfig for ${CLUSTER_NAME} as ${ENV_VAR_NAME}"
          done <<< "$CLUSTER_DATA"

      - name: Get Vault token
        id: vault-token
        uses: blockscout/actions/.github/actions/vault@main
        with:
          url: https://vault.k8s.blockscout.com
          method: jwt
          role: ci-prod
          path: github-jwt
          jwtGithubAudience: "https://github.com/blockscout"
          tlsSkipVerify: "false"
          exportToken: "true"
          secrets: ""

      - name: Prepare kubeconfigs and contexts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.kube/config.d

          write_cfg() {
            local VAR_NAME="$1" FILE_NAME="$2" CTX_NAME="$3"
            local VAL=${!VAR_NAME:-}
            [[ -z "$VAL" ]] && return 0
            # Decode robustly even for multiline values
            printf %s "$VAL" | base64 -d > "$FILE_NAME"
            # Ensure file is non-empty
            if [[ ! -s "$FILE_NAME" ]]; then
              echo "Decoded kubeconfig is empty: $FILE_NAME" >&2
              return 1
            fi
            local CUR_CTX
            CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config current-context 2>/dev/null || true)
            if [[ -z "$CUR_CTX" ]]; then
              CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config get-contexts -o name | head -n1 || true)
            fi
            if [[ -n "$CUR_CTX" && "$CUR_CTX" != "$CTX_NAME" ]]; then
              kubectl --kubeconfig "$FILE_NAME" config rename-context "$CUR_CTX" "$CTX_NAME" || true
            fi
            echo "$FILE_NAME"
          }

          files=()
          
          # Dynamically find all KUBECONFIG_*_BASE64 environment variables
          for var in $(env | grep -E '^KUBECONFIG_.*_BASE64=' | cut -d= -f1); do
            # Extract cluster name from variable name
            # KUBECONFIG_K8S_DEV_BASE64 -> k8s-dev
            CLUSTER_NAME=$(echo "$var" | sed 's/^KUBECONFIG_//' | sed 's/_BASE64$//' | tr '[:upper:]' '[:lower:]' | tr '_' '-')
            
            FILE_PATH="${HOME}/.kube/config.d/${CLUSTER_NAME}"
            
            echo "Processing cluster: ${CLUSTER_NAME} from variable: ${var}"
            out=$(write_cfg "$var" "$FILE_PATH" "$CLUSTER_NAME" || true)
            [[ -n "${out}" ]] && files+=("$FILE_PATH")
          done

          if [[ ${#files[@]} -gt 0 ]]; then
            KUBECONFIG=$(IFS=: ; echo "${files[*]}")
            echo "KUBECONFIG=$KUBECONFIG" >> "$GITHUB_ENV"
            echo "Prepared ${#files[@]} kubeconfig(s)"
          else
            echo "Warning: No kubeconfig files were prepared" >&2
          fi

      - name: Run update-microservices.sh
        shell: bash
        run: |
          set -euo pipefail
          chmod +x helmfile/update-microservices.sh
          echo "KUBECONFIG=$KUBECONFIG"
          ls -l ${HOME}/.kube/config.d || true
          
          # Verify VAULT_TOKEN is available
          if [[ -z "${VAULT_TOKEN:-}" ]]; then
            echo "VAULT_TOKEN is not set!" >&2
            exit 1
          fi
          echo "VAULT_TOKEN is available"
          
          ACTION="${{ inputs.action }}"

          # Dynamically determine available clusters by checking per-cluster kubeconfig files
          declare -a SELECTED=()
          for f in "${HOME}/.kube/config.d/"*; do
            if [[ -s "$f" ]]; then
              cluster_name=$(basename "$f")
              SELECTED+=("$cluster_name")
            fi
          done
          
          if [[ ${#SELECTED[@]} -eq 0 ]]; then
            echo "No per-cluster kubeconfig files found in ${HOME}/.kube/config.d" >&2
            exit 1
          fi
          
          echo "Found ${#SELECTED[@]} cluster(s): ${SELECTED[*]}"

          # Run sequentially per context, setting KUBECONFIG to the cluster-specific file
          for ctx in "${SELECTED[@]}"; do
            echo "=== Running for context: ${ctx} ==="
            export KUBECONFIG="${HOME}/.kube/config.d/${ctx}"
            if [[ -z "${SERVICES_CSV:-}" ]]; then
              echo "Deploying all microservices in ${ctx}"
              ./helmfile/update-microservices.sh "$ACTION" --clusters "$ctx"
            else
              echo "Changed services in ${ctx}: ${SERVICES_CSV}"
              ./helmfile/update-microservices.sh "$ACTION" --clusters "$ctx" --services "${SERVICES_CSV}"
            fi
          done


