name: Deploy microservices

on:
  workflow_call:
    inputs:
      action:
        description: 'update-microservices.sh action: apply|diff|sync'
        required: false
        default: 'apply'
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deploy
    runs-on: [github-k8s-dev-runner]
    container:
      image: dtzar/helm-kubectl:3.19
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: blockscout/actions/.github/actions/checkout@main
        with:
          fetch-depth: "1"

      - name: Install tools
        shell: bash
        run: |
          set -euo pipefail
          helm plugin install https://github.com/jkroepke/helm-secrets
          helm plugin install https://github.com/databus23/helm-diff
          cd /tmp
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64|amd64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
            *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
          esac
          curl -sSLo helmfile.tgz https://github.com/helmfile/helmfile/releases/download/v1.1.0/helmfile_1.1.0_linux_${ARCH}.tar.gz
          tar -xzvf helmfile.tgz
          mv helmfile /usr/local/bin/helmfile
          chmod +x /usr/local/bin/helmfile
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${ARCH}
          chmod +x /usr/local/bin/yq

      - name: Get Vault dev kubeconfig
        id: vault-dev
        uses: blockscout/actions/.github/actions/vault@main
        with:
          url: https://vault.k8s.blockscout.com
          method: jwt
          role: ci-dev
          path: github-jwt
          jwtGithubAudience: "https://github.com/blockscout"
          tlsSkipVerify: "false"
          exportToken: "true"
          secrets: |
            ci/data/dev/kubeconfig/k8s-dev kubeconfig | KUBECONFIG_K8S_DEV_BASE64 ;

      - name: Get Vault prod kubeconfigs
        id: vault-prod
        uses: blockscout/actions/.github/actions/vault@main
        with:
          url: https://vault.k8s.blockscout.com
          method: jwt
          role: ci-prod
          path: github-jwt
          jwtGithubAudience: "https://github.com/blockscout"
          tlsSkipVerify: "false"
          exportToken: "true"
          secrets: |
            ci/data/prod/kubeconfig/k8s-pg kubeconfig | KUBECONFIG_K8S_PG_BASE64 ;
            ci/data/prod/kubeconfig/k8s-prod-1 kubeconfig | KUBECONFIG_K8S_PROD_1_BASE64 ;
            ci/data/prod/kubeconfig/k8s-prod-2 kubeconfig | KUBECONFIG_K8S_PROD_2_BASE64 ;
            ci/data/prod/kubeconfig/k8s-prod-3 kubeconfig | KUBECONFIG_K8S_PROD_3_BASE64 ;
          # ci/data/prod/kubeconfig/k8s-prod-4 kubeconfig | KUBECONFIG_K8S_PROD_4_BASE64 ;

      - name: Prepare kubeconfigs and contexts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.kube/config.d

          write_cfg() {
            local VAR_NAME="$1" FILE_NAME="$2" CTX_NAME="$3"
            local VAL=${!VAR_NAME:-}
            [[ -z "$VAL" ]] && return 0
            # Decode robustly even for multiline values
            printf %s "$VAL" | base64 -d > "$FILE_NAME"
            # Ensure file is non-empty
            if [[ ! -s "$FILE_NAME" ]]; then
              echo "Decoded kubeconfig is empty: $FILE_NAME" >&2
              return 1
            fi
            local CUR_CTX
            CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config current-context 2>/dev/null || true)
            if [[ -z "$CUR_CTX" ]]; then
              CUR_CTX=$(kubectl --kubeconfig "$FILE_NAME" config get-contexts -o name | head -n1 || true)
            fi
            if [[ -n "$CUR_CTX" && "$CUR_CTX" != "$CTX_NAME" ]]; then
              kubectl --kubeconfig "$FILE_NAME" config rename-context "$CUR_CTX" "$CTX_NAME" || true
            fi
            echo "$FILE_NAME"
          }

          files=()
          specs=(
            "KUBECONFIG_K8S_DEV_BASE64:${HOME}/.kube/config.d/k8s-dev:k8s-dev",
            "KUBECONFIG_K8S_PG_BASE64:${HOME}/.kube/config.d/k8s-pg:k8s-pg",
            "KUBECONFIG_K8S_PROD_1_BASE64:${HOME}/.kube/config.d/k8s-prod-1:k8s-prod-1",
            "KUBECONFIG_K8S_PROD_2_BASE64:${HOME}/.kube/config.d/k8s-prod-2:k8s-prod-2",
            "KUBECONFIG_K8S_PROD_3_BASE64:${HOME}/.kube/config.d/k8s-prod-3:k8s-prod-3"
            #"KUBECONFIG_K8S_PROD_4_BASE64:${HOME}/.kube/config.d/k8s-prod-4:k8s-prod-4"
          )
          for spec in "${specs[@]}"; do
            IFS=: read -r var f ctx <<<"$spec"
            out=$(write_cfg "$var" "$f" "$ctx" || true)
            [[ -n "${out}" ]] && files+=("$f")
          done

          if [[ ${#files[@]} -gt 0 ]]; then
            KUBECONFIG=$(IFS=: ; echo "${files[*]}")
            echo "KUBECONFIG=$KUBECONFIG" >> "$GITHUB_ENV"
          fi

      - name: Run update-microservices.sh
        shell: bash
        env:
          VAULT_TOKEN: ${{ env.VAULT_TOKEN }}
        run: |
          set -euo pipefail
          chmod +x helmfile/update-microservices.sh
          echo "KUBECONFIG=$KUBECONFIG"
          ls -l ${HOME}/.kube/config.d || true
          ACTION="${{ inputs.action }}"

          # Determine available clusters by checking per-cluster kubeconfig files
          declare -a CLUSTERS=(k8s-dev k8s-pg k8s-prod-1 k8s-prod-2 k8s-prod-3 k8s-prod-4)
          declare -a SELECTED=()
          for c in "${CLUSTERS[@]}"; do
            f="${HOME}/.kube/config.d/${c}"
            [[ -s "$f" ]] && SELECTED+=("$c")
          done
          if [[ ${#SELECTED[@]} -eq 0 ]]; then
            echo "No per-cluster kubeconfig files found in ${HOME}/.kube/config.d" >&2
            exit 1
          fi

          # Run sequentially per context, setting KUBECONFIG to the cluster-specific file
          for ctx in "${SELECTED[@]}"; do
            echo "=== Running for context: ${ctx} ==="
            export KUBECONFIG="${HOME}/.kube/config.d/${ctx}"
            if [[ -z "${SERVICES_CSV:-}" ]]; then
              echo "Deploying all microservices in ${ctx}"
              ./helmfile/update-microservices.sh "$ACTION" --clusters "$ctx"
            else
              echo "Changed services in ${ctx}: ${SERVICES_CSV}"
              ./helmfile/update-microservices.sh "$ACTION" --clusters "$ctx" --services "${SERVICES_CSV}"
            fi
          done


