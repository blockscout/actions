name: "Vault"
description: "Authenticate to Vault via GitHub OIDC and export secrets to env"
inputs:
  url:
    description: "Vault URL, e.g. https://vault.example.com"
    required: true
  method:
    description: "Auth method: jwt or token"
    required: false
    default: "jwt"
  role:
    description: "Vault role to use for JWT auth"
    required: true
  path:
    description: "Vault auth method path (e.g. github-jwt)"
    required: false
    default: "github-jwt"
  jwtGithubAudience:
    description: "OIDC audience for token request"
    required: false
    default: "sigstore"
  tlsSkipVerify:
    description: "Skip TLS verification (true/false)"
    required: false
    default: "false"
  exportEnv:
    description: "Export secrets as environment variables"
    required: false
    default: "true"
  exportToken:
    description: "Export VAULT_TOKEN to GITHUB_ENV (true/false)"
    required: false
    default: "false"
  outputToken:
    description: "Set 'vault_token' output with Vault token"
    required: false
    default: "false"
  secrets:
    description: |
      Lines in format: "<vault_path> <key> | ENV_NAME ;". Example:
      "ci/data/dev/kubeconfig/k8s-dev kubeconfig | KUBECONFIG_K8S_DEV_BASE64 ;"
    required: false
    default: ""
  namespace:
    description: "Vault namespace (Enterprise)"
    required: false
    default: ""
  ignoreNotFound:
    description: "Do not fail if secret is missing"
    required: false
    default: "false"
  extraHeaders:
    description: "Additional HTTP headers, one per line (Key: Value)"
    required: false
    default: ""
  token:
    description: "Vault token for method=token"
    required: false
    default: ""
outputs:
  vault_token:
    description: "Vault token (client_token)"
    value: ${{ steps.auth.outputs.vault_token }}
runs:
  using: "composite"
  steps:
    - name: Authenticate to Vault and export secrets
      id: auth
      shell: sh
      env:
        VAULT_URL: ${{ inputs.url }}
        VAULT_ROLE: ${{ inputs.role }}
        VAULT_AUTH_PATH: ${{ inputs.path }}
        METHOD: ${{ inputs.method }}
        JWT_AUDIENCE: ${{ inputs.jwtGithubAudience }}
        TLS_SKIP_VERIFY: ${{ inputs.tlsSkipVerify }}
        EXPORT_ENV: ${{ inputs.exportEnv }}
        EXPORT_TOKEN: ${{ inputs.exportToken }}
        OUTPUT_TOKEN: ${{ inputs.outputToken }}
        SECRETS_SPEC: ${{ inputs.secrets }}
        NAMESPACE: ${{ inputs.namespace }}
        IGNORE_NOT_FOUND: ${{ inputs.ignoreNotFound }}
        EXTRA_HEADERS: ${{ inputs.extraHeaders }}
        TOKEN_INPUT: ${{ inputs.token }}
      run: |
        set -eu

        to_lower() {
          printf %s "$1" | tr '[:upper:]' '[:lower:]'
        }

        ensure_yq() {
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64|amd64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
            *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
          esac
          YQ_BIN="/usr/local/bin/yq"
          if [ ! -w "/usr/local/bin" ]; then
            YQ_BIN="/tmp/yq"
            PATH="/tmp:$PATH"; export PATH
          fi
          wget -qO "$YQ_BIN" "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${ARCH}"
          chmod +x "$YQ_BIN"
        }

        # Build curl flags using positional params (portable for sh)
        set -- -sS
        if [ "$(to_lower "${TLS_SKIP_VERIFY}")" = "true" ]; then
          set -- "$@" -k
        fi
        if [ -n "${NAMESPACE}" ]; then
          set -- "$@" -H "X-Vault-Namespace: ${NAMESPACE}"
        fi
        if [ -n "${EXTRA_HEADERS}" ]; then
          while IFS= read -r header; do
            h=$(printf %s "$header" | sed 's/[[:space:]]*$//')
            [ -z "$h" ] && continue
            set -- "$@" -H "$h"
          done <<EOF
          ${EXTRA_HEADERS}
          EOF
        fi
        CURL_FLAGS="$@"

        ensure_yq

        # Authenticate
        VAULT_TOKEN=""
        case "${METHOD}" in
          token)
            VAULT_TOKEN="${TOKEN_INPUT}"
            ;;
          jwt|"")
            if [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" ]; then
              echo "OIDC environment not available. Ensure 'permissions: id-token: write' is set." >&2
              exit 1
            fi
            AUD="${JWT_AUDIENCE}"
            OIDC_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}"
            if [ -n "${AUD}" ]; then
              OIDC_URL="${OIDC_URL}&audience=${AUD}"
            fi
            # shellcheck disable=SC2086
            OIDC_JSON=$(curl -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" ${CURL_FLAGS} "${OIDC_URL}")
            OIDC_TOKEN=$(printf %s "${OIDC_JSON}" | "$YQ_BIN" -p=json -r '.value' -)
            if [ -z "${OIDC_TOKEN}" ] || [ "${OIDC_TOKEN}" = "null" ]; then
              echo "Failed to obtain OIDC token" >&2
              echo "${OIDC_JSON}" >&2
              exit 1
            fi
            LOGIN_BODY=$(printf '{"role":"%s","jwt":"%s"}' "${VAULT_ROLE}" "${OIDC_TOKEN}")
            # shellcheck disable=SC2086
            LOGIN_JSON=$(curl ${CURL_FLAGS} -H 'Content-Type: application/json' -X POST "${VAULT_URL}/v1/auth/${VAULT_AUTH_PATH}/login" -d "${LOGIN_BODY}")
            VAULT_TOKEN=$(printf %s "${LOGIN_JSON}" | "$YQ_BIN" -p=json -r '.auth.client_token' -)
            ;;
          *)
            echo "Unsupported method: ${METHOD}" >&2
            exit 1
            ;;
        esac

        if [ -z "${VAULT_TOKEN}" ] || [ "${VAULT_TOKEN}" = "null" ]; then
          echo "Failed to authenticate to Vault" >&2
          exit 1
        fi

        echo "::add-mask::${VAULT_TOKEN}"
        if [ "$(to_lower "${OUTPUT_TOKEN}")" = "true" ]; then
          echo "vault_token=${VAULT_TOKEN}" >> "$GITHUB_OUTPUT"
        fi
        if [ "$(to_lower "${EXPORT_TOKEN}")" = "true" ]; then
          echo "VAULT_TOKEN=${VAULT_TOKEN}" >> "$GITHUB_ENV"
        fi

        # Parse secrets spec
        if [ -n "${SECRETS_SPEC}" ]; then
          printf "%s\n" "${SECRETS_SPEC}" | tr -d '\r' | while IFS= read -r raw; do
            line=$(printf %s "$raw" | sed 's/[[:space:]]*$//')
            [ -z "$line" ] && continue
            line=$(printf %s "$line" | sed 's/[[:space:]]*;[[:space:]]*$//')
            [ -z "$line" ] && continue
            left=$(printf %s "$line" | awk -F '|' '{print $1}')
            right=$(printf %s "$line" | awk -F '|' '{print $2}')
            left=$(printf %s "$left" | xargs)
            right=$(printf %s "$right" | xargs)
            [ -z "$left" ] && continue
            [ -z "$right" ] && continue
            vault_path=$(printf %s "$left" | awk '{print $1}')
            key=$(printf %s "$left" | awk '{print $2}')
            env_name="$right"
            if [ -z "$vault_path" ] || [ -z "$key" ] || [ -z "$env_name" ]; then
              echo "Invalid secret spec: $line" >&2
              exit 1
            fi
            # shellcheck disable=SC2086
            SECRET_JSON=$(curl ${CURL_FLAGS} -H "X-Vault-Token: ${VAULT_TOKEN}" "${VAULT_URL}/v1/${vault_path}")
            value=$(printf %s "${SECRET_JSON}" | "$YQ_BIN" -p=json -r ".data.data[\"${key}\"]" -)
            if [ -z "${value}" ] || [ "${value}" = "null" ]; then
              if [ "$(to_lower "${IGNORE_NOT_FOUND}")" = "true" ]; then
                continue
              else
                echo "Failed to read key '${key}' from '${vault_path}'" >&2
                echo "${SECRET_JSON}" >&2
                exit 1
              fi
            fi
            echo "::add-mask::${value}"
            if [ "$(to_lower "${EXPORT_ENV}")" = "true" ]; then
              {
                echo "${env_name}<<__EOF__"
                printf "%s\n" "$value"
                echo "__EOF__"
              } >> "$GITHUB_ENV"
            else
              {
                echo "${env_name}<<__EOF__"
                printf "%s\n" "$value"
                echo "__EOF__"
              } >> "$GITHUB_OUTPUT"
            fi
          done
        fi

